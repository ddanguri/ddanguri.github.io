---
layout: post
category : javascript
title: Javascript_Function 총정리
---

### 들어가기에 앞서
웹개발자에게 자바스크립트를 할 줄 아냐고 물어보면 100이면 100 할 줄 안다고 대답할 것 같습니다. 저 또한 그렇습니다. 하지만 정말 잘 아는 것이냐고 물어본다면 또 그렇지는 않습니다. 이 포스트는 다시 한번 저를 담금질하기 위함에 첫 번째 목적이 있고, 조금이라도 도움이 될 누군가를 위해 기록합니다.


### 1장. 자바스크립트 함수는 객체다.

자바스크립트에서 함수는 가장 중요하면서도 흥미로운 존재이자, Java나 C를 주로 다루는 개발자에게는 생소한 존재이기도 합니다. 자바스크립트의 함수의 특징을 가장 간단하게 한 문장으로 표현하자면 아래와 같습니다.

```
자바스크립트에서 함수(Function)은 객체입니다.
```

처음 이 말을 접했을 때, 저는 '아, 그렇구나.' 했습니다. 이러한 개념을 바로 인정하고 받아들였다는 것이 아닙니다. 그때의 전 별 생각이 없었습니다. 아마 다른 똑똑한 분들은 의아해하거나, 어째서? 라는 의문을 가졌을지도 모르겠습니다.

자바스크립트의 함수가 객체라는 말은 앞으로 내가 만들 모든 함수가 Function 타입의 인스턴스라는 말이기도 합니다. 객체이므로 참조 타입이라고 할 수 있으며, 프로퍼티와 메서드를 가지고 있습니다. 함수 이름은 단순히 함수 객체를 가르키는 포인터 역할을 합니다.


아래는 일반적으로 볼 수 있는 기본적인 함수의 형태입니다. function 뒤에 함수이름을 사용하여 함수를 선언하는 방식입니다.

```Javascript
function add(x,y){
  return x+y;
}
```

이 함수는 아래와 같이 사용할수도 있습니다. 코드를 보면 add라는 변수에 function을 할당하였습니다. 이는 다른 말로 함수는 객체이며 변수 add는 함수를 가르키는 포인터라고 할 수 있습니다. 이렇게 작성한 함수는 함수 객체 자체에 이름이 없어 익명 함수(anonymous function) 라고도 합니다.

```Javascript
var add = function(x,y){
  return x+y;
};
```
이렇게 변수에 할당할 때는 보통 다른 값을 할당할 때와 마찬가지로 끝에 세미콜론을 추가합니다.

이렇게 함수에는 두 가지 리터럴 형태가 있지만 중요한 차이점이 있습니다. 처음 방식처럼 함수를 선언하는 방식은 코드가 실행될 시점에 [호이스팅](https://developer.mozilla.org/ko/docs/Glossary/Hoisting) 된다는 점입니다.
다시 한번 설명하자면, 자바스크립트 엔진은 코드를 평가할 때 제일 먼저 함수 선언을 찾은 다음 이들을 맨 위로 올립니다. 즉, 함수 선언이 소스코드에서 함수 실행부분보다 뒤에 있더라도 함수 선언부분을 끌어올립니다(hoisting). 호이스팅에 관해선 추후 따로 다시 정리할 예정입니다.

즉, 아래와 같은 코드가 있더라도 실행될 때 함수 선언부가 호이스팅되기 때문에 오류가 나지 않고 함수가 실행되게 됩니다.

```Javascript
add(10+20); // 함수 실행, 결과값 : 30

function add(x+y){ //함수 선언부
  return x+y;
}
```


다시 함수이름이 단순히 포인터라는 이야기로 돌아오겠습니다.
아래 코드를 보면 방금 만든 add를 copy_add에 할당하였습니다. 그리고 add에 null을 할당하였지만, copy_add는 여전히 함수를 가리키고 있으므로 정상적으로 결과를 출력하게 됩니다.

```Javascript
var copy_add = add;

add = null;

console.log(copy_add(10,20)); // 30
```

함수 이름은 단순히 포인터이므로 오버로딩 또한 불가능하게 됩니다.

```Javascript
function add(x){
  return x+100;
}
function add(x){
  return x+200;
}
console.log(add(100)); //300
```
위의 결과에서 예상할 수 있듯이 마지막에 정의한 함수가 처음에 정의한 함수를 덮어쓰게 됩니다.
